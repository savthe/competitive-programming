#![allow(unused_imports, dead_code, non_camel_case_types)]

// Заметим, что если в подстроке минусов больше, чем плюсов на величину, кратную 3, тогда строка
// перспективная. Пусть плюсов n, а минусов n + 3k, тогда в подстроке найдется по крайней мере
// 2k пар минусов, стоящих справа. Сделаем из них k плюсов. Получим, что плюсов n + k, минусов
// столько же.
// Определим баланс подстроки: (количество минусов) - (количество плюсов). Если плюсов n, тогда
// баланс: (n + 3k) - (n) = 3k - величина, кратная 3. Подстрока является перспективной, если ее
// баланс делится на 3 и притом положительный (минусов не должно быть меньше чем плюсов).
//
// Будем последовательно перебирать правые границы, для каждой вычисляя количество подстрок с
// данной правой границей и неотрицательным балансом, кратным 3.
// Более формально: для правой границы x нас интересует количество подстрок [t, x] для которых
// balance >= 0, balance % 3 == 0.
// Рассмотрим контейнер C, который реализует следующие операции:
// 1. add(t): Добавить элемент t
// 2. inc(): Увеличить все элементы на 1
// 3. dec(): Уменьшить все элементы на 1
// 4. get(): Определить количество неотрицательных элементов, кратных 3.
// Рассмотрим решение задачи с помощью такого контейнера:
// Последовательно перебираем правые границы b. Пусть в C хранятся балансы для всех подстрок вида
// [i, b] для i = 0..b. Тогда в ответ следует добавить C.get() -- количество неотрицательных
// балансов, кратных 3.
// Рассмотрим переход к правой границе b + 1. Как устроены все подстроки, с такой правой границей?
// Если на позиции b + 1 находится минус, то мы добавим 1 к балансам всех подстрок, которые
// заканчивались в b, а если плюс, то вычтем 1. При этом, добавилась новая подстрока длины 1
// ([b + 1, b + 1]) с балансом +1 или -1, поэтому:
// if s[b + 1] == '+' {
//  C.dec();
//  C.add(-1);
// }
// else {
//  C.inc();
//  C.add(1);
// }
// Не забываем добавить в ответ C.get() - количество неотрицательных балансов кратных 3 для подстрок
// с правой границей b + 1.
//
// Опишем реализацию такого контейнера. Рассмотрим массив balance с индексами [-n, ..., n]. Пусть
// i - индекс, который мы считаем нулевым. balance[t] - количество элементов, равных t - i.
// Изначально весь массив заполнен нулями. Таким образом, вычитание из i единицы "сдвигает" ноль
// влево, то есть "увеличивает" все элементы на 1. Сдвиг i вправо "уменьшает" все элементы на 1. Так
// как i - индекс нуля, добавление элемента x реализуется так: balance[x + i] += 1.
// Для ответа на вопрос о количестве неотрицательных элементов, кратных 3, мы будем поддерживать 3
// счетчика: s0, s1, s2 -- количества неотрицательных элементов с остатками при делении на 3,
// равными 0, 1, 2 соответственно. При увеличении всех элементов на 1 эти переменные циклически
// сдвигаются: s1_new = s0, s2_new = s1, s0_new = s2. И к s0_new добавляется элемент, находящийся
// на позиции balance[i - 1] (элемент -1 стал равен 0).

fn solve() {
    // s[k] - количество неотрицательных балансов с остатком k.
    let mut s = [0, 0, 0];

    // Индекс нуля.
    let mut i = 0;

    let n: us = inp::read1();
    // Контейнер балансов для всех подстрок с фиксированной правой границей.
    // Для "эмуляции" отрицательных индексов, к i будем добавлять сдвиг на n.
    let mut balance: Vec<us> = vec![0; 2 * n + 1];

    let v = inp::read_bytes();
    let mut result = 0;
    // Последовательно перебираем символы строки.
    for x in v.iter() {
        match *x {
            b'+' => {
                // Ко всем подстрокам добавляется плюс справа. Их балансы уменьшаются на 1.

                // Количество нулей (элемент, на который указывает i) становится количеством минус
                // единиц, так как ноль сдвигается вправо. Вычитаем их из s[0].
                s[0] -= balance[(n as i32 + i) as us];

                // Сдвиг нуля вправо.
                i += 1;

                // Циклический сдвиг счетчиков, так как все остатки изменились на 1.
                (s[0], s[1], s[2]) = (s[1], s[2], s[0]);

                // Добавился новый элемент: -1.
                balance[(n as i32 - 1 + i) as us] += 1;
            }
            _ => {
                // Ко всем подстрокам добавляется минус справа. Их балансы увеличиваются на 1.
                i -= 1;

                (s[0], s[1], s[2]) = (s[2], s[0], s[1]);

                // Количество минус единиц становится количеством нулей, их нужно учесть в s[0].
                s[0] += balance[(n as i32 + i) as us];

                // Добавился элемент, равный 1.
                balance[(n as i32 + 1 + i) as us] += 1;
                s[1] += 1;
            }
        }
        result += s[0];
    }

    println!("{}", result);
}

fn main() {
    for _ in 0..inp::read1() {
        solve();
    }
}

/* Auxiliary stuff */
type us = usize;

use std::collections::BTreeMap;
use std::collections::HashMap;
use std::collections::HashSet;

mod inp {
    use std::io;
    use std::str::FromStr;

    pub fn read_matrix<T: FromStr>(n: usize) -> Vec<Vec<T>> {
        let mut a: Vec<Vec<T>> = vec![];
        for _ in 0..n {
            a.push(read_vec::<T>());
        }
        a
    }

    pub fn read_vec<T: FromStr>() -> Vec<T> {
        read_line()
            .split_whitespace()
            .map(|x| x.parse().ok().unwrap())
            .collect::<Vec<T>>()
    }

    pub fn read_line() -> String {
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        input.trim_end().to_string()
    }

    pub fn read_bytes() -> Vec<u8> {
        let mut input = String::new();
        io::stdin().read_line(&mut input).unwrap();
        input.trim_end().bytes().collect()
    }

    pub fn read1<T: FromStr>() -> T {
        read_line().trim().parse().ok().unwrap()
    }

    pub fn read2<T1: FromStr, T2: FromStr>() -> (T1, T2) {
        let input = read_line();
        let mut i = input.split_whitespace();
        let a: T1 = i.next().unwrap().parse().ok().unwrap();
        let b: T2 = i.next().unwrap().parse().ok().unwrap();
        (a, b)
    }

    pub fn read3<T1: FromStr, T2: FromStr, T3: FromStr>() -> (T1, T2, T3) {
        let input = read_line();
        let mut i = input.split_whitespace();
        let a: T1 = i.next().unwrap().parse().ok().unwrap();
        let b: T2 = i.next().unwrap().parse().ok().unwrap();
        let c: T3 = i.next().unwrap().parse().ok().unwrap();
        (a, b, c)
    }

    pub fn read4<T1: FromStr, T2: FromStr, T3: FromStr, T4: FromStr>() -> (T1, T2, T3, T4) {
        let input = read_line();
        let mut i = input.split_whitespace();
        let a: T1 = i.next().unwrap().parse().ok().unwrap();
        let b: T2 = i.next().unwrap().parse().ok().unwrap();
        let c: T3 = i.next().unwrap().parse().ok().unwrap();
        let d: T4 = i.next().unwrap().parse().ok().unwrap();
        (a, b, c, d)
    }
}
